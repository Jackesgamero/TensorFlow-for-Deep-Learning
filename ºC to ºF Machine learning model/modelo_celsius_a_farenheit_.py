# -*- coding: utf-8 -*-
"""Modelo Celsius a Farenheit .ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kAjjBG4xzJD--73u7cetpZmXHgxg_67c

## Dependencias
"""

import tensorflow as tf

import numpy as np
import logging
logger = tf.get_logger()
logger.setLevel(logging.ERROR)

"""## Datos de entrenamiento"""

celsius_q    = np.array([-40, -10,  0,  8, 15, 22,  38],  dtype=float)
fahrenheit_a = np.array([-40,  14, 32, 46, 59, 72, 100],  dtype=float)

for i,c in enumerate(celsius_q):
  print("{} degrees Celsius = {} degrees Fahrenheit".format(c, fahrenheit_a[i]))

"""## Creamos una red densa con una sola capa

* `input_shape=[1]` - la entrada es un valor único

* `units = 1` - numero de neuronas en la capa
"""

lvl0 = tf.keras.layers.Dense(units=1, input_shape=[1])

"""## Ensamblamos la capa en el modelo"""

model = tf.keras.Sequential([lvl0])

"""## Compilamos el modelo antes del entrenamiento

Para ello le proporcionamos al modelo la **funcion de perdida** (error cuadratico medio) y la **función de optimizador** (Adam)
"""

model.compile(loss='mean_squared_error',
              optimizer=tf.keras.optimizers.Adam(0.1))

"""## Entrenamos el modelo

Durante el entrenamiento, el modelo toma valores en grados Celsius, realiza un cálculo utilizando las variables internas actuales (llamadas "pesos") y genera valores que deben ser el equivalente en Fahrenheit. Dado que los pesos se establecen inicialmente de forma aleatoria, la salida no se acercará al valor correcto. La diferencia entre la salida real y la salida deseada se calcula utilizando la función de pérdida, y la función del optimizador indica cómo se deben ajustar los pesos.

Este ciclo de calcular, comparar y ajustar está controlado por el método `fit`. El primer argumento son las entradas, el segundo argumento son las salidas deseadas. El argumento `epochs`especifica cuántas veces se debe ejecutar este ciclo y el argumento `verbose` controla la cantidad de salida que produce el método..
"""

history = model.fit(celsius_q, fahrenheit_a, epochs=500, verbose=False)
print("Finished training the model")

"""## Mostrar estadísticas de entrenamiento"""

import matplotlib.pyplot as plt
plt.xlabel('Epoch Number')
plt.ylabel("Loss Magnitude")
plt.plot(history.history['loss'])

"""## Usamos el modelo para predecir valores"""

print(model.predict([100.0]))

"""## Observar los pesos que el modelo ha obtenido"""

print("These are the layer variables: {}".format(lvl0.get_weights()))